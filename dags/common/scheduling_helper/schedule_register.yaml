# ==============================================================================
# AIRFLOW DAG SCHEDULE REGISTRY
# ==============================================================================
#
# DESCRIPTION:
#   This registry serves as the source of truth for deterministic DAG scheduling.
#   It implements sequential execution logic to prevent overlapping runtimes
#   on shared resources (e.g., TPU clusters), ensuring cluster stability
#   by strictly serializing workloads.
#
# HOW TO GENERATE/UPDATE THIS FILE:
#   1. INITIALIZATION:
#      Use the `generate_initial_registry(path, key)` utility script. It scans
#      the project folder and generates a YAML template. Or manually create a
#      new entry by following the YAML format explained below.
#
#   2. MAINTENANCE & DEVELOPMENT:
#      Whenever a NEW DAG is developed or an OLD DAG is maintained, you MUST
#      update this file to reflect the changes in the schedule:
#      - Add NEW DAGs to 'require_scheduling' to include them in the timeline.
#      - Adjust 'timeout' if the DAG execution time changes.
#      - Move DAGs between 'require_scheduling' and 'no_scheduling_required'
#        depending on whether they need a managed start time.
#
# YAML FORMAT EXPLANATION:
#   project_key:
#     schedule_name:  [String] Human-readable project label.
#     project_path:   [Path]   Source code location of the DAGs.
#     cluster_name:   [String] Target hardware/cluster metadata.
#
#     require_scheduling: [List] ORDER-SENSITIVE queue.
#       - id:      [String] Must exactly match the Airflow `dag_id`.
#       - timeout: [HH:MM:SS] The buffer allocated for this DAG.
#                  The next DAG starts at: (Previous Start + Timeout + 15m).
#
#     no_scheduling_required: [List] DAGs that are triggered manually,
#                             by other DAGs, or don't occupy cluster slots.
#
# ==============================================================================

# Default values for all projects
default:
  anchor_time: "08:00:00"
  margin_minutes: 15

tpu_observability:
  schedule_name: "Tpu Observability"
  project_path: "dags/tpu_observability/"
  cluster_name: "TPU_V5P_128_CLUSTER"
  anchor_time: "03:20:00"   # Overrides global 08:00
  margin_minutes: 10        # Overrides global 15
  require_scheduling:
    gke_node_pool_label_update: "00:30:00"
    gke_node_pool_status: "00:30:00"
    jobset_rollback_ttr: "01:30:00"
    jobset_ttr_node_pool_resize: "01:30:00"
    jobset_ttr_pod_delete: "01:30:00"
    multi-host-availability-rollback: "00:30:00"
    node_pool_ttr_disk_size: "01:30:00"
    node_pool_ttr_update_label: "01:30:00"
    tpu_info_format_validation_dag: "00:30:00"
    tpu_sdk_monitoring_validation: "00:30:00"
    jobset_ttr_kill_process: "01:30:00"

  no_scheduling_required:
    validate_interruption_count_gce_bare_metal_preemption: null
    validate_interruption_count_gce_defragmentation: null
    validate_interruption_count_gce_eviction: null
    validate_interruption_count_gce_host_error: null
    validate_interruption_count_gce_hwsw_maintenance: null
    validate_interruption_count_gce_migrate_on_hwsw_maintenance: null
    validate_interruption_count_gce_other: null
    validate_interruption_count_gke_bare_metal_preemption: null
    validate_interruption_count_gke_defragmentation: null
    validate_interruption_count_gke_eviction: null
    validate_interruption_count_gke_host_error: null
    validate_interruption_count_gke_hwsw_maintenance: null
    validate_interruption_count_gke_migrate_on_hwsw_maintenance: null
    validate_interruption_count_gke_other: null
